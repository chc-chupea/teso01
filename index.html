<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>æ‰‹ç›¸å ã„ã‚«ãƒ¡ãƒ©è¨ºæ–­</title>
  <link href="https://fonts.googleapis.com/css2?family=Kosugi+Maru&display=swap" rel="stylesheet" />
  <style>
    body {
      font-family: 'Kosugi Maru', sans-serif;
      background-color: #fdf5e6;
      color: #333;
      margin: 0;
      padding: 1em;
      text-align: center;
    }
    h1 {
      font-size: 1.5em;
      color: #7566a0;
      margin-bottom: 0.5em;
    }
    select,
    button {
      font-size: 1em;
      padding: 0.5em 1.2em;
      margin: 1em 0;
      border-radius: 12px;
      border: 1px solid #ccc;
      background-color: #fff;
      cursor: pointer;
      user-select: none;
    }
    #videoElement,
    canvas {
      width: 100%;
      max-width: 400px;
      border-radius: 10px;
      margin: 0.5em 0;
      background: black;
    }
    .result {
      background-color: #fff;
      border-radius: 10px;
      padding: 1em;
      margin-top: 1em;
      box-shadow: 0 0 10px rgba(0, 0, 0, 0.1);
      white-space: pre-line;
      min-height: 6em;
    }
    .share-btn {
      background-color: #ffe0b2;
      color: #5d4037;
      margin: 0.5em;
      border: none;
      cursor: pointer;
      user-select: none;
    }
    #countdown {
      font-size: 5em;
      font-weight: bold;
      color: #ff5722;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      user-select: none;
      text-shadow: 0 0 8px #ff5722;
      display: none;
      z-index: 100;
    }
    #container {
      position: relative;
      display: inline-block;
    }
  </style>
</head>
<body>
  <h1>ã‚¹ãƒãƒ›æ‰‹ç›¸å ã„ã‚«ãƒ¡ãƒ©è¨ºæ–­</h1>
  <p>ã¾ãšã¯ã‚¸ãƒ£ãƒ³ãƒ«ã‚’é¸ã‚“ã§ã­ï¼ï¼ˆå…¨éƒ¨è¨ºæ–­ã‚‚OKï¼‰</p>
  <select id="genre">
    <option value="">ã‚¸ãƒ£ãƒ³ãƒ«ã‚’é¸ã‚“ã§ãã ã•ã„</option>
    <option value="all">å…¨éƒ¨è‡ªå‹•è¨ºæ–­</option>
    <option value="love">æ‹æ„›</option>
    <option value="work">ä»•äº‹</option>
    <option value="money">é‡‘é‹</option>
    <option value="health">å¥åº·</option>
    <option value="personality">æ€§æ ¼</option>
  </select>
  <br />
  <button id="startButton">ã‚«ãƒ¡ãƒ©èµ·å‹•</button>
  <button id="shutterButton" style="display:none;">ğŸ“¸ ã‚·ãƒ£ãƒƒã‚¿ãƒ¼</button>

  <div id="container">
    <video autoplay playsinline id="videoElement"></video>
    <canvas id="canvas"></canvas>
    <div id="countdown">3</div>
  </div>

  <div class="result" id="result"></div>
  <button class="share-btn" onclick="shareLINE()">LINEã§ã‚·ã‚§ã‚¢</button>
  <button class="share-btn" onclick="shareInstagram()">ã‚¤ãƒ³ã‚¹ã‚¿DMã§é€ã‚‹</button>

  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
  <script src="https://docs.opencv.org/4.6.0/opencv.js"></script>
  <script>
    const video = document.getElementById("videoElement");
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const resultBox = document.getElementById("result");
    const startButton = document.getElementById("startButton");
    const shutterButton = document.getElementById("shutterButton");
    const countdownEl = document.getElementById("countdown");

    let handednessResult = "";
    let currentHand = "left";
    let model;
    let camera;
    let isProcessing = false;
    let streamingStarted = false;
    let mediaStream = null;

    const detailedComments = {
      left: {
        personality: Array.from({ length: 20 }, (_, i) => `ã€æ€§æ ¼Lv${i + 1}ã€‘ç¹Šç´°ã§æ€æ…®æ·±ã„ä¸€é¢ã‚ã‚Š`),
        love: Array.from({ length: 20 }, (_, i) => `ã€æ‹æ„›Lv${i + 1}ã€‘ç†æƒ³é«˜ã‚ã§å†…ã«ç§˜ã‚ãŸæƒ…ç†±æ´¾`),
        health: Array.from({ length: 20 }, (_, i) => `ã€å¥åº·Lv${i + 1}ã€‘è‡ªå·±ç®¡ç†åŠ›ãŒå…‰ã‚‹ã‚¿ã‚¤ãƒ—`),
        all: Array.from({ length: 20 }, (_, i) => `ã€å…¨ä½“Lv${i + 1}ã€‘å†…é¢ã®é­…åŠ›ãŒã˜ã‚ã˜ã‚ä¼ã‚ã‚‹äºº`),
      },
      right: {
        work: Array.from({ length: 20 }, (_, i) => `ã€ä»•äº‹Lv${i + 1}ã€‘ç€å®Ÿã«ä¿¡é ¼ã‚’ç©ã‚€åŠªåŠ›å®¶`),
        money: Array.from({ length: 20 }, (_, i) => `ã€é‡‘é‹Lv${i + 1}ã€‘å …å®Ÿæ´¾ã§ã‚³ãƒ„ã‚³ãƒ„å‹ã®è²¯è“„ã‚¹ã‚¿ã‚¤ãƒ«`),
        health: Array.from({ length: 20 }, (_, i) => `ã€å¥åº·Lv${i + 1}ã€‘æ´»ç™ºã§ãƒã‚¸ãƒ†ã‚£ãƒ–ä½“è³ª`),
        love: Array.from({ length: 20 }, (_, i) => `ã€æ‹æ„›Lv${i + 1}ã€‘å‰å‘ããªæ‹ã®ç«‹å½¹è€…`),
        all: Array.from({ length: 20 }, (_, i) => `ã€å…¨ä½“Lv${i + 1}ã€‘ä»ŠãŒå‹è² ã©ãã€åŠªåŠ›ã¯å®Ÿã‚’çµã¶`),
      },
    };

    const generateDetailedComment = (score, genre, hand) => {
      const dict = detailedComments[hand][genre] || detailedComments[hand].all;
      const level = Math.max(0, Math.min(19, Math.floor(score)));
      return dict[level] || "åˆ†æä¸­â€¦";
    };

    const hands = new Hands({
      locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`,
    });

    hands.setOptions({
      maxNumHands: 1,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7,
    });

    hands.onResults(async (results) => {
      if (!isProcessing) return;

      if (results.multiHandedness && results.multiHandedness.length > 0) {
        currentHand = results.multiHandedness[0].label === "Right" ? "right" : "left";
        handednessResult = currentHand === "right" ? "å³æ‰‹ï¼ˆç¾åœ¨ãƒ»é‹å‹¢ï¼‰" : "å·¦æ‰‹ï¼ˆç´ è³ªãƒ»æ€§æ ¼ï¼‰";
      }

      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

      const src = cv.imread(canvas);
      const gray = new cv.Mat();
      const edges = new cv.Mat();

      cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
      cv.Canny(gray, edges, 50, 150);

      let contours = new cv.MatVector();
      let hierarchy = new cv.Mat();
      cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

      let totalLength = 0;
      let totalAngle = 0;
      let count = 0;

      for (let i = 0; i < contours.size(); i++) {
        let contour = contours.get(i);
        const length = cv.arcLength(contour, false);
        if (length < 30) {
          contour.delete();
          continue;
        }

        const rotatedRect = cv.minAreaRect(contour);
        let angle = rotatedRect.angle;
        if (angle < -45) angle += 90;

        totalLength += length;
        totalAngle += angle;
        count++;
        contour.delete();
      }

      contours.delete();
      hierarchy.delete();
      gray.delete();
      src.delete();
      edges.delete();

      const avgLength = count > 0 ? totalLength / count : 0;
      const avgAngle = count > 0 ? totalAngle / count : 0;

      const lengthScore = Math.min(1, avgLength / 300);
      const angleScore = (avgAngle + 45) / 90;

      let combinedScore = Math.floor((lengthScore * 0.6 + angleScore * 0.4) * 19);

      let tfImg = tf.browser.fromPixels(canvas);
      tfImg = tf.image.resizeBilinear(tfImg, [64, 64]);
      tfImg = tfImg.expandDims(0).toFloat().div(255);

      let predictionText = "";
      if (model) {
        const prediction = await model.predict(tfImg).data();
        const labels = ["æ„Ÿæƒ…ç·š", "é ­è„³ç·š", "ç”Ÿå‘½ç·š", "é‹å‘½ç·š"];
        const maxIndex = prediction.indexOf(Math.max(...prediction));
        predictionText = `AIåˆ¤å®šï¼š${labels[maxIndex]}ãŒæ˜ç­ã§ã™`;

        if (labels[maxIndex] === "ç”Ÿå‘½ç·š") {
          combinedScore = Math.min(19, combinedScore + 3);
        }
      }
      tfImg.dispose();

      const genre = document.getElementById("genre").value || "all";
      const comment = generateDetailedComment(combinedScore, genre, currentHand);

      resultBox.innerHTML = `<h2>${handednessResult} è¨ºæ–­</h2>
        <p>${comment}</p>
        <p>${predictionText}</p>
        <p>ç·šã®å¹³å‡é•·ã•: ${avgLength.toFixed(1)} px<br>ç·šã®å‚¾ã: ${avgAngle.toFixed(1)}Â°</p>`;

      isProcessing = false;
      shutterButton.disabled = false;
      shutterButton.textContent = "ğŸ“¸ ã‚·ãƒ£ãƒƒã‚¿ãƒ¼";
    });

    // å¤–ã‚«ãƒ¡ãƒ©å„ªå…ˆã§deviceIdæŒ‡å®šã™ã‚‹é–¢æ•°
    async function getBackCameraDeviceId() {
      if (!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices) {
        return null;
      }
      const devices = await navigator.mediaDevices.enumerateDevices();
      const videoDevices = devices.filter(d => d.kind === "videoinput");
      // ãƒ©ãƒ™ãƒ«ã« back ã¾ãŸã¯ rear ãŒã‚ã‚‹ã‚‚ã®ã‚’æ¢ã™
      for (const device of videoDevices) {
        if (device.label.toLowerCase().includes("back") || device.label.toLowerCase().includes("rear")) {
          return device.deviceId;
        }
      }
      // è¦‹ã¤ã‹ã‚‰ãªã‘ã‚Œã°æœ€åˆã®ãƒ“ãƒ‡ã‚ªå…¥åŠ›ã‚’è¿”ã™
      return videoDevices.length > 0 ? videoDevices[0].deviceId : null;
    }

    async function startCameraFunc() {
      if (streamingStarted) return;
      try {
        const backCameraId = await getBackCameraDeviceId();
        if (!backCameraId) {
          alert("ã‚«ãƒ¡ãƒ©ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚");
          return;
        }
        console.log("å¤–ã‚«ãƒ¡ãƒ©ãƒ‡ãƒã‚¤ã‚¹ID:", backCameraId);
        if (mediaStream) {
          // å¤ã„ã‚¹ãƒˆãƒªãƒ¼ãƒ ãŒã‚ã‚Œã°åœæ­¢
          mediaStream.getTracks().forEach(track => track.stop());
        }
        mediaStream = await navigator.mediaDevices.getUserMedia({
          video: { deviceId: { exact: backCameraId } },
          audio: false,
        });
        video.srcObject = mediaStream;

        camera = new Camera(video, {
          onFrame: async () => {
            if (!isProcessing) return;
            await hands.send({ image: video });
          },
          width: 640,
          height: 480,
        });
        camera.start();

        model = await tf.loadLayersModel("/model/model.json");

        streamingStarted = true;
        startButton.style.display = "none";
        shutterButton.style.display = "inline-block";
        resultBox.textContent = "ã‚«ãƒ¡ãƒ©èµ·å‹•å®Œäº†ï¼æ‰‹ã‚’æ˜ ã—ã¦ã‚·ãƒ£ãƒƒã‚¿ãƒ¼ãƒœã‚¿ãƒ³ã‚’æŠ¼ã—ã¦ã­ã€‚";
      } catch (e) {
        alert("ã‚«ãƒ¡ãƒ©ã®èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
      }
    }

    startButton.addEventListener("click", () => {
      startCameraFunc();
    });

    shutterButton.addEventListener("click", () => {
      if (!streamingStarted || isProcessing) return;

      let count = 3;
      countdownEl.textContent = count;
      countdownEl.style.display = "block";
      shutterButton.disabled = true;
      shutterButton.textContent = "æ’®å½±ä¸­...";

      const countdownInterval = setInterval(() => {
        count--;
        if (count > 0) {
          countdownEl.textContent = count;
        } else {
          clearInterval(countdownInterval);
          countdownEl.style.display = "none";

          isProcessing = true;
          resultBox.textContent = "å ã„ä¸­â€¦âœ¨";
          hands.send({ image: video });
        }
      }, 1000);
    });

    function shareLINE() {
      const text = encodeURIComponent("æ‰‹ç›¸å ã„ã‚„ã£ã¦ã¿ãŸï¼\nè¨ºæ–­çµæœã¯ã“ã¡ã‚‰â†’ https://your-app-link.com");
      window.open(`https://line.me/R/msg/text/?${text}`, "_blank");
    }

    function shareInstagram() {
      alert("ã‚¤ãƒ³ã‚¹ã‚¿ã®DMã«ã¯ã€è¨ºæ–­çµæœã‚’ã‚¹ã‚¯ã‚·ãƒ§ã—ã¦é€ã£ã¦ã­ï¼");
    }
  </script>
</body>
</html>
