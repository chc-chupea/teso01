<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>æ‰‹ç›¸å ã„ã‚«ãƒ¡ãƒ©è¨ºæ–­</title>
<link href="https://fonts.googleapis.com/css2?family=Kosugi+Maru&display=swap" rel="stylesheet" />
<style>
  body {
    font-family: 'Kosugi Maru', sans-serif;
    background-color: #fdf5e6;
    color: #333;
    margin: 0;
    padding: 1em;
    text-align: center;
    position: relative;
  }
  h1 {
    font-size: 1.5em;
    color: #7566a0;
    margin-bottom: 0.5em;
  }
  select, button {
    font-size: 1em;
    padding: 0.5em 1em;
    margin: 1em 0.5em;
    border-radius: 12px;
    border: 1px solid #ccc;
    background-color: #fff;
    cursor: pointer;
  }
  #videoElement, canvas {
    width: 100%;
    max-width: 400px;
    border-radius: 10px;
    margin: 0.5em 0;
  }
  .result {
    background-color: #fff;
    border-radius: 10px;
    padding: 1em;
    margin-top: 1em;
    box-shadow: 0 0 10px rgba(0,0,0,0.1);
    white-space: pre-line;
    min-height: 5em;
  }
  #countdownOverlay {
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.75);
    color: white;
    font-size: 6em;
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    user-select: none;
  }
  #countdownText {
    font-weight: 900;
    text-shadow: 0 0 10px #fff;
  }
  .share-btn {
    background-color: #ffe0b2;
    color: #5d4037;
    margin: 0.5em;
    border: none;
    cursor: pointer;
  }
</style>
</head>
<body>
<h1>ã‚¹ãƒãƒ›æ‰‹ç›¸å ã„ã‚«ãƒ¡ãƒ©è¨ºæ–­</h1>
<p>ã¾ãšã¯ã‚¸ãƒ£ãƒ³ãƒ«ã‚’é¸ã‚“ã§ã­ï¼ï¼ˆå…¨éƒ¨è¨ºæ–­ã‚‚OKï¼‰</p>
<select id="genre">
  <option value="">ã‚¸ãƒ£ãƒ³ãƒ«ã‚’é¸ã‚“ã§ãã ã•ã„</option>
  <option value="all">å…¨éƒ¨è‡ªå‹•è¨ºæ–­</option>
  <option value="love">æ‹æ„›</option>
  <option value="work">ä»•äº‹</option>
  <option value="money">é‡‘é‹</option>
  <option value="health">å¥åº·</option>
  <option value="personality">æ€§æ ¼</option>
</select>
<br />
<button id="startCameraBtn">ã‚«ãƒ¡ãƒ©èµ·å‹•ã—ã¦æ‰‹ã‚’æ˜ ã™</button>
<button id="shutterButton" style="display:none;">ğŸ“¸ ã‚·ãƒ£ãƒƒã‚¿ãƒ¼</button>

<video autoplay playsinline id="videoElement" muted></video>
<canvas id="canvas" style="display:none;"></canvas>

<div id="countdownOverlay">
  <div id="countdownText"></div>
</div>

<div class="result" id="result"></div>

<button class="share-btn" onclick="shareLINE()">LINEã§ã‚·ã‚§ã‚¢</button>
<button class="share-btn" onclick="shareInstagram()">ã‚¤ãƒ³ã‚¹ã‚¿DMã§é€ã‚‹</button>

<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
<script src="https://docs.opencv.org/4.6.0/opencv.js"></script>
<script>
  const startCameraBtn = document.getElementById("startCameraBtn");
  const shutterButton = document.getElementById("shutterButton");
  const video = document.getElementById("videoElement");
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");
  const resultBox = document.getElementById("result");
  const countdownOverlay = document.getElementById("countdownOverlay");
  const countdownText = document.getElementById("countdownText");

  let currentHand = "left";
  let handednessResult = "";
  let model = null;
  let camera = null;
  let hands = null;
  let processing = false;

  // è©³ç´°ã‚³ãƒ¡ãƒ³ãƒˆè¾æ›¸
  const detailedComments = {
    left: {
      personality: Array.from({ length: 20 }, (_, i) => `ã€æ€§æ ¼Lv${i + 1}ã€‘ç¹Šç´°ã§æ€æ…®æ·±ã„ä¸€é¢ã‚ã‚Š`),
      love: Array.from({ length: 20 }, (_, i) => `ã€æ‹æ„›Lv${i + 1}ã€‘ç†æƒ³é«˜ã‚ã§å†…ã«ç§˜ã‚ãŸæƒ…ç†±æ´¾`),
      health: Array.from({ length: 20 }, (_, i) => `ã€å¥åº·Lv${i + 1}ã€‘è‡ªå·±ç®¡ç†åŠ›ãŒå…‰ã‚‹ã‚¿ã‚¤ãƒ—`),
      all: Array.from({ length: 20 }, (_, i) => `ã€å…¨ä½“Lv${i + 1}ã€‘å†…é¢ã®é­…åŠ›ãŒã˜ã‚ã˜ã‚ä¼ã‚ã‚‹äºº`),
    },
    right: {
      work: Array.from({ length: 20 }, (_, i) => `ã€ä»•äº‹Lv${i + 1}ã€‘ç€å®Ÿã«ä¿¡é ¼ã‚’ç©ã‚€åŠªåŠ›å®¶`),
      money: Array.from({ length: 20 }, (_, i) => `ã€é‡‘é‹Lv${i + 1}ã€‘å …å®Ÿæ´¾ã§ã‚³ãƒ„ã‚³ãƒ„å‹ã®è²¯è“„ã‚¹ã‚¿ã‚¤ãƒ«`),
      health: Array.from({ length: 20 }, (_, i) => `ã€å¥åº·Lv${i + 1}ã€‘æ´»ç™ºã§ãƒã‚¸ãƒ†ã‚£ãƒ–ä½“è³ª`),
      love: Array.from({ length: 20 }, (_, i) => `ã€æ‹æ„›Lv${i + 1}ã€‘å‰å‘ããªæ‹ã®ç«‹å½¹è€…`),
      all: Array.from({ length: 20 }, (_, i) => `ã€å…¨ä½“Lv${i + 1}ã€‘ä»ŠãŒå‹è² ã©ãã€åŠªåŠ›ã¯å®Ÿã‚’çµã¶`),
    },
  };

  function generateDetailedComment(score, genre, hand) {
    const dict = detailedComments[hand][genre] || detailedComments[hand].all;
    const level = Math.max(0, Math.min(19, Math.floor(score)));
    return dict[level] || "åˆ†æä¸­â€¦";
  }

  function showCountdownAndRunAnalysis() {
    let count = 3;
    countdownText.textContent = count;
    countdownOverlay.style.display = "flex";

    const interval = setInterval(() => {
      count--;
      if (count > 0) {
        countdownText.textContent = count;
      } else {
        clearInterval(interval);
        countdownText.textContent = "å ã„ä¸­â€¦âœ¨";
        runAnalysis().finally(() => {
          countdownOverlay.style.display = "none";
          shutterButton.disabled = false;
          shutterButton.style.display = "inline-block";
        });
      }
    }, 1000);
  }

  async function runAnalysis() {
    if (!video.videoWidth || !video.videoHeight) {
      resultBox.textContent = "æ˜ åƒãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“ã€‚ã‚‚ã†ä¸€åº¦ã‚·ãƒ£ãƒƒã‚¿ãƒ¼ã‚’æŠ¼ã—ã¦ãã ã•ã„ã€‚";
      return;
    }
    processing = true;
    canvas.width = video.videoWidth;
    canvas.height = video.videoHeight;
    ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

    const src = cv.imread(canvas);
    const gray = new cv.Mat();
    const edges = new cv.Mat();

    cv.cvtColor(src, gray, cv.COLOR_RGBA2GRAY);
    cv.Canny(gray, edges, 50, 150);

    let contours = new cv.MatVector();
    let hierarchy = new cv.Mat();
    cv.findContours(edges, contours, hierarchy, cv.RETR_EXTERNAL, cv.CHAIN_APPROX_SIMPLE);

    let totalLength = 0;
    let totalAngle = 0;
    let count = 0;

    for (let i = 0; i < contours.size(); i++) {
      let contour = contours.get(i);
      const length = cv.arcLength(contour, false);
      if (length < 30) {
        contour.delete();
        continue;
      }
      const rotatedRect = cv.minAreaRect(contour);
      let angle = rotatedRect.angle;
      if (angle < -45) angle += 90;

      totalLength += length;
      totalAngle += angle;
      count++;
      contour.delete();
    }

    contours.delete();
    hierarchy.delete();
    gray.delete();
    src.delete();
    edges.delete();

    const avgLength = count > 0 ? totalLength / count : 0;
    const avgAngle = count > 0 ? totalAngle / count : 0;

    const lengthScore = Math.min(1, avgLength / 300);
    const angleScore = (avgAngle + 45) / 90;
    let combinedScore = Math.floor((lengthScore * 0.6 + angleScore * 0.4) * 19);

    let tfImg = tf.browser.fromPixels(canvas);
    tfImg = tf.image.resizeBilinear(tfImg, [64, 64]);
    tfImg = tfImg.expandDims(0).toFloat().div(255);

    let predictionText = "";
    if (model) {
      const prediction = await model.predict(tfImg).data();
      const labels = ["æ„Ÿæƒ…ç·š", "é ­è„³ç·š", "ç”Ÿå‘½ç·š", "é‹å‘½ç·š"];
      const maxIndex = prediction.indexOf(Math.max(...prediction));
      predictionText = `AIåˆ¤å®šï¼š${labels[maxIndex]}ãŒæ˜ç­ã§ã™`;
      if (labels[maxIndex] === "ç”Ÿå‘½ç·š") {
        combinedScore = Math.min(19, combinedScore + 3);
      }
    }
    tfImg.dispose();

    const genre = document.getElementById("genre").value || "all";
    const comment = generateDetailedComment(combinedScore, genre, currentHand);

    resultBox.innerHTML = `<h2>${handednessResult} è¨ºæ–­</h2>
      <p>${comment}</p>
      <p>${predictionText}</p>
      <p>ç·šã®å¹³å‡é•·ã•: ${avgLength.toFixed(1)} px<br>ç·šã®å‚¾ã: ${avgAngle.toFixed(1)}Â°</p>`;

    processing = false;
  }

  // MediaPipe Handsã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
  hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });
  hands.setOptions({
    maxNumHands: 1,
    modelComplexity: 1,
    minDetectionConfidence: 0.7,
    minTrackingConfidence: 0.7
  });
  hands.onResults((results) => {
    if (results.multiHandedness && results.multiHandedness.length > 0) {
      currentHand = results.multiHandedness[0].label === "Right" ? "right" : "left";
      handednessResult = currentHand === "right" ? "å³æ‰‹ï¼ˆç¾åœ¨ãƒ»é‹å‹¢ï¼‰" : "å·¦æ‰‹ï¼ˆç´ è³ªãƒ»æ€§æ ¼ï¼‰";
    }
  });

  startCameraBtn.addEventListener("click", async () => {
    startCameraBtn.disabled = true;
    resultBox.textContent = "";
    try {
      const constraints = { video: { facingMode: "environment" }, audio: false };
      const stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject = stream;

      camera = new Camera(video, {
        onFrame: async () => {
          await hands.send({ image: video });
        },
        width: 640,
        height: 480
      });
      await camera.start();

      model = await tf.loadLayersModel("/model/model.json");
      shutterButton.style.display = "inline-block";
      startCameraBtn.style.display = "none";
    } catch (err) {
      alert("ã‚«ãƒ¡ãƒ©èµ·å‹•ã«å¤±æ•—ã—ã¾ã—ãŸ: " + err.message);
      startCameraBtn.disabled = false;
    }
  });

  shutterButton.addEventListener("click", () => {
    if (processing) return;
    shutterButton.disabled = true;
    showCountdownAndRunAnalysis();
  });

  function shareLINE() {
    const text = encodeURIComponent("æ‰‹ç›¸å ã„ã‚„ã£ã¦ã¿ãŸï¼\nè¨ºæ–­çµæœã¯ã“ã¡ã‚‰â†’ https://your-app-link.com");
    window.open(`https://line.me/R/msg/text/?${text}`, "_blank");
  }
  function shareInstagram() {
    alert("ã‚¤ãƒ³ã‚¹ã‚¿ã®DMã«ã¯ã€è¨ºæ–­çµæœã‚’ã‚¹ã‚¯ã‚·ãƒ§ã—ã¦é€ã£ã¦ã­ï¼");
  }
</script>
</body>
</html>
